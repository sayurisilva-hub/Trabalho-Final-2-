import typing
from typing import Optional

__version__: str
PyCF_ONLY_AST: int
_identifier = str

class AST:
    _attributes: typing.Tuple[str, ...]
    _fields: typing.Tuple[str, ...]
    def __init__(self, *args, **kwargs) -> None: ...

class mod(AST): ...

class Module(mod):
    body: typing.List[stmt]

class Interactive(mod):
    body: typing.List[stmt]

class Expression(mod):
    body: expr

class Suite(mod):
    body: typing.List[stmt]

class stmt(AST):
    lineno: int
    col_offset: int

class FunctionDef(stmt):
    name: _identifier
    args: arguments
    body: typing.List[stmt]
    decorator_list: typing.List[expr]

class ClassDef(stmt):
    name: _identifier
    bases: typing.List[expr]
    body: typing.List[stmt]
    decorator_list: typing.List[expr]

class Return(stmt):
    value: Optional[expr]

class Delete(stmt):
    targets: typing.List[expr]

class Assign(stmt):
    targets: typing.List[expr]
    value: expr

class AugAssign(stmt):
    target: expr
    op: operator
    value: expr

class Print(stmt):
    dest: Optional[expr]
    values: typing.List[expr]
    nl: bool

class For(stmt):
    target: expr
    iter: expr
    body: typing.List[stmt]
    orelse: typing.List[stmt]

class While(stmt):
    test: expr
    body: typing.List[stmt]
    orelse: typing.List[stmt]

class If(stmt):
    test: expr
    body: typing.List[stmt]
    orelse: typing.List[stmt]

class With(stmt):
    context_expr: expr
    optional_vars: Optional[expr]
    body: typing.List[stmt]

class Raise(stmt):
    type: Optional[expr]
    inst: Optional[expr]
    tback: Optional[expr]

class TryExcept(stmt):
    body: 